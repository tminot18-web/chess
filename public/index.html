<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Live Eval Chess — Online</title>

    <link
      rel="stylesheet"
      href="https://unpkg.com/cm-chessboard@3.15.5/styles/cm-chessboard.css"
    />

    <style>
      :root {
        --bg: #0b0f17;
        --text: #e7eefc;
        --muted: #a7b4cf;
        --line: rgba(255, 255, 255, 0.08);

        /* ✅ Sidebar (chat+controls) width target */
        --sidebarW: 340px;
        --gap: 14px;
        --pad: 14px;
      }

      * { box-sizing: border-box; }

      html, body {
        height: 100%;
        margin: 0;
        overflow: hidden; /* ✅ no page scrolling */
      }

      body {
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        background:
          radial-gradient(800px 400px at 20% 0%, rgba(125, 211, 252, 0.13), transparent 60%),
          radial-gradient(600px 300px at 80% 10%, rgba(34, 197, 94, 0.10), transparent 60%),
          var(--bg);
        color: var(--text);
      }

      /* ✅ Layout: board dominates, sidebar is slim (about half of what you had) */
      .wrap {
        height: 100vh;
        display: grid;
        grid-template-columns: 1fr var(--sidebarW);
        gap: var(--gap);
        padding: var(--pad);
      }

      .card {
        background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
        border: 1px solid var(--line);
        border-radius: 14px;
        padding: 12px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.25);
        overflow: hidden;
        min-height: 0;
      }

      /* ---------- LEFT: BOARD (fills the freed space) ---------- */
      .left {
        display: grid;
        grid-template-rows: auto 1fr;
        gap: 10px;
        min-height: 0;
      }

      .topbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .brand h1 {
        font-size: 16px;
        margin: 0;
        letter-spacing: 0.2px;
      }
      .brand span {
        font-size: 12px;
        color: var(--muted);
      }

      .pills { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }
      .pill {
        border: 1px solid var(--line);
        padding: 5px 8px;
        border-radius: 999px;
        font-size: 12px;
        color: var(--muted);
        background: rgba(0,0,0,0.12);
      }

      /* ✅ Give the board an explicit, guaranteed square pixel size */
      #boardStage {
        min-height: 0;
        display: grid;
        place-items: center;
      }

      #board {
        /* boardSize = min(available viewport height, available viewport width minus sidebar) */
        width: min(
          calc(100vw - var(--sidebarW) - (var(--pad) * 2) - var(--gap) - 24px),
          calc(100vh - (var(--pad) * 2) - 72px)
        );
        height: min(
          calc(100vw - var(--sidebarW) - (var(--pad) * 2) - var(--gap) - 24px),
          calc(100vh - (var(--pad) * 2) - 72px)
        );
        max-width: 100%;
        max-height: 100%;
      }

      /* ---------- RIGHT: CONTROLS (top) + CHAT (bottom) ---------- */
      .right {
        display: grid;
        grid-template-rows: auto 1fr;
        gap: var(--gap);
        min-height: 0;
      }

      .panelTitle {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 8px;
        letter-spacing: 0.3px;
        text-transform: uppercase;
      }

      .controlsGrid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }

      .block {
        background: rgba(0,0,0,0.14);
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 10px;
        min-height: 0;
      }

      button, input { font: inherit; }
      button {
        cursor: pointer;
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px 10px;
        color: var(--text);
        background: rgba(0,0,0,0.15);
        transition: transform .05s ease, background .2s ease;
      }
      button:hover { background: rgba(125,211,252,0.10); }
      button:active { transform: translateY(1px); }
      button.primary { border-color: rgba(125,211,252,0.4); }
      button.danger { border-color: rgba(239,68,68,0.4); }

      input {
        width: 100%;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: rgba(0,0,0,0.15);
        color: var(--text);
      }

      .row { display: flex; gap: 8px; }
      .row > * { flex: 1; }

      /* Eval smaller (board is star) */
      .evalWrap {
        display: grid;
        grid-template-columns: 18px 1fr;
        gap: 10px;
        align-items: center;
      }
      .evalBar {
        width: 18px;
        height: 140px;
        border-radius: 999px;
        border: 1px solid var(--line);
        overflow: hidden;
        background: rgba(0,0,0,0.25);
        position: relative;
      }
      .evalFill {
        position: absolute;
        bottom: 0;
        width: 100%;
        height: 50%;
        background: linear-gradient(180deg, rgba(34,197,94,0.9), rgba(34,197,94,0.55));
      }
      .evalBig {
        font-size: 26px;
        letter-spacing: 0.2px;
      }
      .evalSub {
        font-size: 12px;
        color: var(--muted);
        line-height: 1.4;
      }

      /* Chat */
      .chatCard {
        display: grid;
        grid-template-rows: auto 1fr auto;
        gap: 10px;
        min-height: 0;
      }

      .chatLog {
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 10px;
        background: rgba(0,0,0,0.14);
        overflow-y: auto;
        min-height: 0;
      }

      .msg {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 8px;
        padding: 6px 0;
        border-bottom: 1px dashed rgba(255,255,255,0.06);
      }
      .msg:last-child { border-bottom: none; }
      .tag {
        font-size: 11px;
        padding: 2px 6px;
        border: 1px solid var(--line);
        border-radius: 999px;
        color: var(--muted);
        height: fit-content;
      }
      .msg .text {
        font-size: 13px;
        line-height: 1.35;
        word-break: break-word;
      }
      .tag.sys { border-color: rgba(125,211,252,0.35); color: rgba(125,211,252,0.95); }
      .tag.user { border-color: rgba(255,255,255,0.12); color: var(--text); }

      .chatSend {
        display: flex;
        gap: 8px;
      }
      .chatSend input { flex: 1; }
      .chatSend button { width: 96px; }

      .muted { color: var(--muted); font-size: 12px; line-height: 1.45; }

      @media (max-width: 1050px) {
        /* Stack on small screens */
        .wrap {
          grid-template-columns: 1fr;
          grid-template-rows: 62vh 1fr;
        }
        :root { --sidebarW: 100%; }
        #board {
          width: min(calc(100vw - (var(--pad) * 2) - 24px), calc(62vh - 60px));
          height: min(calc(100vw - (var(--pad) * 2) - 24px), calc(62vh - 60px));
        }
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <!-- LEFT: BOARD -->
      <div class="card left">
        <div class="topbar">
          <div class="brand">
            <h1>Live Eval Chess</h1>
            <span>Online rooms + local Stockfish eval (browser)</span>
          </div>
          <div class="pills">
            <div class="pill" id="modePill">idle</div>
            <div class="pill" id="roomPill">room: —</div>
            <div class="pill" id="playersPill">players: 0</div>
          </div>
        </div>

        <div id="boardStage">
          <div id="board"></div>
        </div>
      </div>

      <!-- RIGHT: CONTROLS TOP + CHAT BOTTOM -->
      <div class="right">
        <div class="card">
          <div class="panelTitle">Controls</div>
          <div class="controlsGrid">
            <div class="block">
              <div class="panelTitle" style="margin-bottom:6px;">Online</div>
              <div class="row" style="margin-bottom: 8px;">
                <button class="primary" id="playOnlineBtn">Play Online</button>
                <button class="danger" id="cancelBtn">Cancel</button>
              </div>
              <div class="row" style="margin-bottom: 8px;">
                <button id="createBtn">Create Room</button>
                <button id="copyBtn">Copy Link</button>
              </div>
              <div class="row">
                <input id="joinInput" placeholder="ROOM CODE (e.g. 8KJ3QZ)" />
                <button id="joinBtn">Join</button>
              </div>
              <div style="height: 10px;"></div>
              <button id="restartBtn">Restart (Local Only)</button>
            </div>

            <div class="block">
              <div class="panelTitle" style="margin-bottom:6px;">Evaluation</div>
              <div class="evalWrap">
                <div class="evalBar">
                  <div class="evalFill" id="evalFill"></div>
                </div>
                <div>
                  <div class="evalBig" id="evalBig">0.0</div>
                  <div class="evalSub" id="evalSub">
                    Eval is local. Depth 14. Neutral until first move.
                  </div>
                  <div style="height:8px;"></div>
                  <div class="muted">Server authoritative + resync after refresh/disconnect.</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="card chatCard">
          <div class="panelTitle">Room Feed</div>
          <div class="chatLog" id="chatLog"></div>
          <div class="chatSend">
            <input id="chatInput" placeholder="Type a message…" />
            <button id="sendBtn">Send</button>
          </div>
        </div>
      </div>
    </div>

    <!-- deps -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chess.js@0.13.4/chess.min.js"></script>
    <script src="https://unpkg.com/cm-chessboard@3.15.5/cm-chessboard.js"></script>

    <script>
      // cm-chessboard v3 global
      const { Chessboard, INPUT_EVENT_TYPE } = window.cmChessboard;
      const { Chess } = window;

      // DOM
      const modePill = document.getElementById("modePill");
      const roomPill = document.getElementById("roomPill");
      const playersPill = document.getElementById("playersPill");

      const playOnlineBtn = document.getElementById("playOnlineBtn");
      const cancelBtn = document.getElementById("cancelBtn");
      const createBtn = document.getElementById("createBtn");
      const joinBtn = document.getElementById("joinBtn");
      const joinInput = document.getElementById("joinInput");
      const restartBtn = document.getElementById("restartBtn");
      const copyBtn = document.getElementById("copyBtn");

      const evalFill = document.getElementById("evalFill");
      const evalBig = document.getElementById("evalBig");
      const evalSub = document.getElementById("evalSub");

      const chatLog = document.getElementById("chatLog");
      const chatInput = document.getElementById("chatInput");
      const sendBtn = document.getElementById("sendBtn");

      // State
      let currentRoom = null;
      let myRole = null; // "white" | "black"
      let mode = "idle";
      let moveNumber = 0;

      function setMode(m) { mode = m; modePill.textContent = m; }
      function updateTopPills(players) {
        roomPill.textContent = `room: ${currentRoom || "—"}`;
        playersPill.textContent = `players: ${players ?? 0}`;
      }
      function clearSession() {
        currentRoom = null;
        myRole = null;
        const u = new URL(location.href);
        u.searchParams.delete("room");
        history.replaceState({}, "", u);
        updateTopPills(0);
      }

      function addMsg(kind, tag, text) {
        const row = document.createElement("div");
        row.className = "msg";

        const t = document.createElement("div");
        t.className = `tag ${kind}`;
        t.textContent = tag;

        const b = document.createElement("div");
        b.className = "text";
        b.textContent = text;

        row.appendChild(t);
        row.appendChild(b);
        chatLog.appendChild(row);
        chatLog.scrollTop = chatLog.scrollHeight;
      }
      function sys(text) { addMsg("sys", "sys", text); }

      // Chess + board
      const game = new Chess();
      const boardEl = document.getElementById("board");

      const board = new Chessboard(boardEl, {
        position: game.fen(),
        responsive: true,
        style: { cssClass: "default", showCoordinates: true },
      });

      function setOrientation() {
        if (myRole === "black") board.setOrientation("black");
        else board.setOrientation("white");
      }

      // ✅ Hard force the board to render after layout and whenever size may change
      function forceBoardRender() {
        try { board.setPosition(game.fen()); } catch {}
      }
      window.addEventListener("load", () => {
        requestAnimationFrame(() => {
          forceBoardRender();
          setTimeout(forceBoardRender, 50);
          setTimeout(forceBoardRender, 200);
        });
      });
      window.addEventListener("resize", () => requestAnimationFrame(forceBoardRender));

      function setEvalBarFromCp(whiteCp) {
        const clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x));
        const normalized = clamp(whiteCp, -800, 800);
        const pct = ((normalized + 800) / 1600) * 100;
        evalFill.style.height = pct + "%";
      }

      function resetLocalGame() {
        game.reset();
        moveNumber = 0;
        board.setPosition(game.fen());
        setEvalBarFromCp(0);
        requestEval(game.fen());
        forceBoardRender();
      }

      function canMoveNow() {
        const turn = game.turn();
        if (myRole === "white") return turn === "w";
        if (myRole === "black") return turn === "b";
        return false;
      }

      // Stockfish (browser worker)
      let sf = null;
      let sfReady = false;

      function ensureStockfish() {
        if (sf) return;
        sf = new Worker("/engine/stockfish-uci.js");
        sf.onmessage = (e) => {
          const line = (e.data || "").toString();
          if (!line) return;

          if (line === "uciok") { sfReady = true; return; }

          if (line.includes("score cp")) {
            const m = line.match(/score cp (-?\d+)/);
            if (m) setEvalFromEngine(parseInt(m[1], 10));
          }

          if (line.includes("score mate")) {
            const m = line.match(/score mate (-?\d+)/);
            if (m) {
              const mate = parseInt(m[1], 10);
              const cp = mate > 0 ? 10000 : -10000;
              setEvalFromEngine(cp, mate);
            }
          }
        };

        sf.postMessage("uci");
        sf.postMessage("setoption name Threads value 2");
        sf.postMessage("setoption name Hash value 64");
        sf.postMessage("isready");
      }

      function requestEval(fen) {
        ensureStockfish();
        if (!sfReady) return;
        sf.postMessage("ucinewgame");
        sf.postMessage("position fen " + fen);
        sf.postMessage("go depth 14");
      }

      function setEvalFromEngine(cp, mate = null) {
        let whiteCp = cp;
        if (game.turn() === "b") whiteCp = -cp;

        if (mate !== null) {
          evalBig.textContent = mate > 0 ? `M${mate}` : `M${Math.abs(mate)}`;
          evalSub.textContent = "Mate sequence detected";
          setEvalBarFromCp(whiteCp);
          return;
        }

        evalBig.textContent = (whiteCp / 100).toFixed(1);
        evalSub.textContent = "cp — white good up, black good down";
        setEvalBarFromCp(whiteCp);
      }

      // Socket
      const socket = io();
      socket.on("connect", () => sys("socket connected"));

      socket.on("queue:status", ({ state }) => {
        if (state === "searching") {
          clearSession();
          setMode("searching");
          sys("searching…");
        } else {
          setMode("idle");
          sys("idle");
        }
      });

      socket.on("match:found", ({ room, role }) => {
        currentRoom = room;
        myRole = role === "w" ? "white" : "black";
        setMode("matched");
        updateTopPills(2);
        setOrientation();
        resetLocalGame();
        socket.emit("state:request", { room: currentRoom });

        const u = new URL(location.href);
        u.searchParams.set("room", currentRoom);
        history.replaceState({}, "", u);

        sys(`match found: ${room} (${myRole})`);
      });

      socket.on("room:created", ({ room }) => {
        currentRoom = room;
        myRole = "white";
        setMode("matched");
        updateTopPills(1);
        setOrientation();
        resetLocalGame();
        socket.emit("state:request", { room: currentRoom });

        const u = new URL(location.href);
        u.searchParams.set("room", currentRoom);
        history.replaceState({}, "", u);

        sys(`room created: ${room}`);
      });

      socket.on("room:joined", ({ room, role, players }) => {
        currentRoom = room;
        myRole = role === "w" ? "white" : "black";
        setMode("matched");
        updateTopPills(players ?? null);
        setOrientation();
        resetLocalGame();
        socket.emit("state:request", { room: currentRoom });

        const u = new URL(location.href);
        u.searchParams.set("room", currentRoom);
        history.replaceState({}, "", u);

        sys(`joined: ${room} (${myRole})`);
      });

      socket.on("room:update", ({ room, players }) => {
        if (room === currentRoom) updateTopPills(players);
      });

      socket.on("room:error", ({ error }) => sys("room error: " + error));
      socket.on("opponent:left", () => sys("opponent left"));

      socket.on("state:sync", (s) => {
        try {
          if (!s || !s.fen) return;
          game.load(s.fen);
          board.setPosition(game.fen());
          moveNumber = typeof s.moveNumber === "number" ? s.moveNumber : 0;
          requestEval(game.fen());
          if (typeof s.players === "object") {
            const players = (s.players.w ? 1 : 0) + (s.players.b ? 1 : 0);
            updateTopPills(players);
          }
          forceBoardRender();
        } catch (e) {
          console.error("state:sync error", e);
        }
      });

      socket.on("move:accepted", ({ fen, moveNumber: mn }) => {
        if (!fen) return;
        game.load(fen);
        board.setPosition(game.fen());
        if (typeof mn === "number") moveNumber = mn;
        requestEval(game.fen());
        forceBoardRender();
      });

      socket.on("move:rejected", (p) => {
        try {
          if (p && p.fen) {
            game.load(p.fen);
            board.setPosition(game.fen());
            moveNumber = typeof p.moveNumber === "number" ? p.moveNumber : moveNumber;
            requestEval(game.fen());
          }
          if (p && p.reason) sys("move rejected: " + p.reason);
          forceBoardRender();
        } catch (e) {
          console.error("move:rejected error", e);
        }
      });

      socket.on("chat", (m) => {
        try {
          if (!m) return;
          if (m.kind === "sys") addMsg("sys", m.at || "sys", m.text || "");
          else if (m.kind === "user") addMsg("user", `${m.at || ""} ${m.from || ""}`.trim(), m.text || "");
          else addMsg("sys", "chat", m.text || "");
        } catch (e) {
          console.error("chat handler error", e);
        }
      });

      // Move input
      board.enableMoveInput((event) => {
        if (!currentRoom) return false;
        if (mode !== "matched") return false;
        if (!(myRole === "white" || myRole === "black")) return false;

        if (event.type === INPUT_EVENT_TYPE.moveInputStarted) return canMoveNow();

        if (event.type === INPUT_EVENT_TYPE.validateMoveInput) {
          if (!canMoveNow()) {
            sys("not your turn");
            board.setPosition(game.fen());
            return false;
          }

          const from = event.squareFrom;
          const to = event.squareTo;

          const mv = game.move({ from, to, promotion: "q" });
          if (!mv) {
            sys("illegal move");
            board.setPosition(game.fen());
            return false;
          }

          board.setPosition(game.fen());
          requestEval(game.fen());

          socket.emit("move:submit", {
            room: currentRoom,
            move: { from, to, promotion: "q" },
            clientMoveNumber: moveNumber,
          });

          return true;
        }

        return true;
      });

      // Buttons
      playOnlineBtn.onclick = () => {
        sys("Play Online clicked");
        clearSession();
        setMode("searching");
        socket.emit("queue:join");
      };

      cancelBtn.onclick = () => {
        sys("Cancel clicked");
        socket.emit("queue:cancel");
        clearSession();
        setMode("idle");
      };

      createBtn.onclick = () => {
        sys("Create clicked");
        socket.emit("queue:cancel");
        socket.emit("room:create");
      };

      joinBtn.onclick = () => {
        const code = (joinInput.value || "").trim().toUpperCase();
        if (!code) return;
        sys("Join clicked: " + code);
        socket.emit("queue:cancel");
        socket.emit("room:join", { room: code });
      };

      restartBtn.onclick = () => { resetLocalGame(); sys("restarted (local)"); };

      copyBtn.onclick = async () => {
        const u = new URL(location.href);
        if (currentRoom) u.searchParams.set("room", currentRoom);
        history.replaceState({}, "", u);
        await navigator.clipboard.writeText(u.toString());
        sys("room link copied");
      };

      function sendChat() {
        const t = (chatInput.value || "").trim();
        if (!t) return;
        socket.emit("chat:send", { text: t });
        chatInput.value = "";
      }

      sendBtn.onclick = sendChat;
      chatInput.addEventListener("keydown", (e) => { if (e.key === "Enter") sendChat(); });

      // auto-join from URL
      const roomParam = new URL(location.href).searchParams.get("room");
      if (roomParam) {
        const code = roomParam.trim().toUpperCase();
        sys("auto-join: " + code);
        socket.emit("room:join", { room: code });
      }

      // init
      setMode("idle");
      updateTopPills(0);
      resetLocalGame();
      sys("ready");
      forceBoardRender();
    </script>
  </body>
</html>

