<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Live Eval Chess</title>

    <!-- cm-chessboard CSS (local assets you already have in /public/cm-assets) -->
    <link rel="stylesheet" href="/cm-assets/chessboard.css" />
    <link rel="icon" href="data:," />

    <style>
      :root {
        --bg: #0b0f14;
        --panel: #0f1520;
        --panel2: #111a29;
        --text: #dbe3ee;
        --muted: rgba(219, 227, 238, 0.7);
        --border: rgba(219, 227, 238, 0.12);
        --good: #28d17c;
        --warn: #f4b23b;
        --bad: #ff4d4d;
        --accent: #7c5cff;
        --shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
        --radius: 16px;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        background: radial-gradient(1200px 700px at 30% 10%, rgba(124, 92, 255, 0.15), transparent 60%),
          radial-gradient(800px 500px at 80% 30%, rgba(40, 209, 124, 0.12), transparent 60%),
          var(--bg);
        color: var(--text);
      }
      a {
        color: var(--accent);
        text-decoration: none;
      }
      .wrap {
        max-width: 1100px;
        margin: 0 auto;
        padding: 24px;
        display: grid;
        grid-template-columns: 1fr 340px;
        gap: 18px;
      }
      @media (max-width: 980px) {
        .wrap {
          grid-template-columns: 1fr;
        }
      }
      .card {
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
        border: 1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
      }
      .header {
        padding: 14px 16px;
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
      }
      .title {
        font-size: 16px;
        letter-spacing: 0.3px;
        font-weight: 700;
      }
      .pillRow {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: flex-end;
      }
      .pill {
        font-size: 12px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.03);
        color: var(--muted);
      }
      .pill strong {
        color: var(--text);
      }

      .boardCard {
        overflow: hidden;
      }
      .boardBody {
        display: grid;
        grid-template-columns: 18px 1fr;
        gap: 12px;
        padding: 14px;
        align-items: stretch;
      }
      @media (max-width: 980px) {
        .boardBody {
          grid-template-columns: 14px 1fr;
        }
      }

      /* Eval bar that "pops" */
      .evalBar {
        width: 14px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid var(--border);
        position: relative;
        overflow: hidden;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05), 0 0 18px rgba(124, 92, 255, 0.18);
      }
      .evalFillWhite {
        position: absolute;
        bottom: 50%;
        left: 0;
        right: 0;
        height: 50%;
        background: linear-gradient(180deg, rgba(219, 227, 238, 0.95), rgba(219, 227, 238, 0.55));
      }
      .evalFillBlack {
        position: absolute;
        top: 50%;
        left: 0;
        right: 0;
        height: 50%;
        background: linear-gradient(180deg, rgba(10, 12, 14, 0.95), rgba(10, 12, 14, 0.55));
      }
      .evalMarker {
        position: absolute;
        left: 0;
        right: 0;
        height: 2px;
        top: calc(50% - 1px);
        background: rgba(124, 92, 255, 0.8);
        filter: drop-shadow(0 0 8px rgba(124, 92, 255, 0.9));
      }

      /* Board container */
      #board {
        width: 100%;
        max-width: 640px;
        aspect-ratio: 1 / 1;
        margin: 0 auto;
      }

      .rightCol {
        display: grid;
        grid-template-rows: auto auto 1fr;
        gap: 12px;
      }

      .panelBody {
        padding: 12px 14px;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      button,
      input {
        font: inherit;
      }
      button {
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        padding: 10px 12px;
        border-radius: 12px;
        cursor: pointer;
        transition: transform 0.08s ease, background 0.12s ease, border-color 0.12s ease;
      }
      button:hover {
        background: rgba(255, 255, 255, 0.06);
        border-color: rgba(124, 92, 255, 0.35);
      }
      button:active {
        transform: translateY(1px);
      }
      button.primary {
        border-color: rgba(124, 92, 255, 0.45);
        background: rgba(124, 92, 255, 0.18);
      }
      button.danger {
        border-color: rgba(255, 77, 77, 0.45);
        background: rgba(255, 77, 77, 0.12);
      }
      button:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }
      input[type="text"] {
        flex: 1;
        min-width: 160px;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.25);
        color: var(--text);
        outline: none;
      }
      input[type="text"]::placeholder {
        color: rgba(219, 227, 238, 0.45);
      }

      .kv {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        margin-top: 10px;
      }
      .kv .k {
        color: var(--muted);
        font-size: 12px;
      }
      .kv .v {
        font-weight: 700;
      }

      .evalNum {
        font-size: 28px;
        font-weight: 800;
        letter-spacing: 0.4px;
        line-height: 1;
      }
      .small {
        color: var(--muted);
        font-size: 12px;
      }

      .feed {
        height: 340px;
        overflow: auto;
        padding: 10px 12px;
        border-top: 1px solid var(--border);
      }
      .msg {
        margin: 0 0 10px 0;
        padding: 10px 10px;
        border: 1px solid rgba(219, 227, 238, 0.12);
        background: rgba(0, 0, 0, 0.18);
        border-radius: 12px;
      }
      .msg .meta {
        display: flex;
        gap: 8px;
        align-items: baseline;
        margin-bottom: 6px;
        color: rgba(219, 227, 238, 0.75);
        font-size: 11px;
      }
      .tag {
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid rgba(219, 227, 238, 0.15);
        background: rgba(255, 255, 255, 0.03);
      }
      .tag.sys {
        border-color: rgba(124, 92, 255, 0.25);
      }
      .tag.user {
        border-color: rgba(40, 209, 124, 0.25);
      }
      .tag.err {
        border-color: rgba(255, 77, 77, 0.35);
      }
      .msg .text {
        white-space: pre-wrap;
        font-size: 13px;
        line-height: 1.35;
      }
      .chatRow {
        display: flex;
        gap: 8px;
        padding: 12px 12px 14px 12px;
      }
      .chatRow button {
        padding: 10px 12px;
        border-radius: 12px;
      }

      .modeLine {
        margin-top: 10px;
        font-size: 12px;
        color: var(--muted);
      }
      .modeLine strong {
        color: var(--text);
      }
    </style>

    <!-- Socket.IO client from server -->
    <script src="/socket.io/socket.io.js"></script>

    <!-- chess.js for legality + fen/pgn -->
    <script src="https://cdn.jsdelivr.net/npm/chess.js@0.10.3/chess.min.js"></script>
  </head>

  <body>
    <div class="wrap">
      <!-- Board + eval bar -->
      <div class="card boardCard">
        <div class="header">
          <div class="title">Live Eval Chess</div>
          <div class="pillRow">
            <div class="pill">room: <strong id="roomPill">—</strong></div>
            <div class="pill">role: <strong id="rolePill">—</strong></div>
            <div class="pill">players: <strong id="playersPill">0</strong></div>
          </div>
        </div>

        <div class="boardBody">
          <div class="evalBar" aria-label="eval bar">
            <div class="evalFillWhite" id="evalWhiteFill"></div>
            <div class="evalFillBlack" id="evalBlackFill"></div>
            <div class="evalMarker"></div>
          </div>

          <div id="board"></div>
        </div>
      </div>

      <!-- Right column -->
      <div class="rightCol">
        <!-- Controls -->
        <div class="card">
          <div class="header">
            <div class="title">Controls</div>
            <div class="pillRow">
              <div class="pill">engine: <strong id="engineStatus">starting…</strong></div>
            </div>
          </div>

          <div class="panelBody">
            <div class="row">
              <button id="playOnlineBtn" class="primary">Play Online</button>
              <button id="cancelBtn" class="danger" disabled>Cancel</button>
              <button id="restartBtn" disabled>Restart</button>
              <button id="copyBtn" disabled>Copy Link</button>
            </div>

            <div class="kv">
              <div class="k">Eval</div>
              <div class="v evalNum" id="evalNum">+0.0</div>
            </div>

            <div class="modeLine">
              mode: <strong id="modeText">idle</strong> • you can only move when it's your turn
            </div>

            <hr style="border: none; border-top: 1px solid var(--border); margin: 14px 0" />

            <div class="row" style="margin-bottom: 8px">
              <button id="createBtn">Create (Friend Room)</button>
              <input id="joinInput" type="text" placeholder="ROOM CODE" />
              <button id="joinBtn">Join</button>
            </div>

            <div class="small">
              Online matchmaking: waits until 2 players are searching. Friend rooms: share link with ?room=CODE.
            </div>
          </div>
        </div>

        <!-- Feed + chat -->
        <div class="card" style="display: grid; grid-template-rows: auto 1fr auto">
          <div class="header">
            <div class="title">Feed / Chat</div>
            <div class="pillRow">
              <div class="pill">log</div>
            </div>
          </div>

          <div id="feed" class="feed"></div>

          <div class="chatRow">
            <input id="chatInput" type="text" placeholder="message…" />
            <button id="sendBtn">Send</button>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import { COLOR, Chessboard, FEN, INPUT_EVENT_TYPE } from "https://unpkg.com/cm-chessboard@8.7.8/src/Chessboard.js";

      // ---------- DOM ----------
      const feedEl = document.getElementById("feed");
      const roomEl = document.getElementById("roomPill");
      const roleEl = document.getElementById("rolePill");
      const playersEl = document.getElementById("playersPill");
      const evalNumEl = document.getElementById("evalNum");
      const evalWhiteFill = document.getElementById("evalWhiteFill");
      const evalBlackFill = document.getElementById("evalBlackFill");
      const engineStatusEl = document.getElementById("engineStatus");
      const modeTextEl = document.getElementById("modeText");

      const playOnlineBtn = document.getElementById("playOnlineBtn");
      const cancelBtn = document.getElementById("cancelBtn");
      const restartBtn = document.getElementById("restartBtn");
      const copyBtn = document.getElementById("copyBtn");

      const createBtn = document.getElementById("createBtn");
      const joinBtn = document.getElementById("joinBtn");
      const joinInput = document.getElementById("joinInput");

      const chatInput = document.getElementById("chatInput");
      const sendBtn = document.getElementById("sendBtn");

      // ---------- Feed helpers ----------
      function addMsg(kind, from, text) {
        const d = document.createElement("div");
        d.className = "msg";
        const meta = document.createElement("div");
        meta.className = "meta";
        const tag = document.createElement("span");
        tag.className = "tag " + (kind === "sys" ? "sys" : kind === "err" ? "err" : "user");
        tag.textContent = kind;
        const who = document.createElement("span");
        who.textContent = from;
        meta.appendChild(tag);
        meta.appendChild(who);

        const body = document.createElement("div");
        body.className = "text";
        body.textContent = text;

        d.appendChild(meta);
        d.appendChild(body);

        feedEl.appendChild(d);
        feedEl.scrollTop = feedEl.scrollHeight;
      }

      function sys(text) {
        addMsg("sys", new Date().toTimeString().slice(0, 8), text);
      }
      function ok(text) {
        addMsg("sys", "ok", text);
      }
      function warn(text) {
        addMsg("sys", "warn", text);
      }
      function err(text) {
        addMsg("err", "error", text);
      }

      // ---------- State ----------
      let currentRoom = null;
      let myRole = null; // "white" | "black"
      let mode = "idle"; // idle | searching | matched
      let engineReady = false;

      function setMode(next) {
        mode = next;
        modeTextEl.textContent = mode;

        const searching = mode === "searching";
        playOnlineBtn.disabled = searching;
        cancelBtn.disabled = !searching;

        // while searching, you can't move
        if (searching) restartBtn.disabled = true;
      }

      function updateTopPills(players = null) {
        roomEl.textContent = currentRoom || "—";
        roleEl.textContent = myRole || "—";
        if (players !== null) playersEl.textContent = String(players);
        copyBtn.disabled = !currentRoom;
        restartBtn.disabled = !(myRole === "white" || myRole === "black");
      }

      function clearSession() {
        currentRoom = null;
        myRole = null;
        // remove room param from URL (so Play Online is "clean")
        const u = new URL(location.href);
        u.searchParams.delete("room");
        history.replaceState({}, "", u);
        updateTopPills(0);
      }

      // ---------- Board ----------
      const boardEl = document.getElementById("board");

      const board = new Chessboard(boardEl, {
        position: FEN.start,
        sprite: { url: "/cm-assets/pieces/staunty.svg" },
        style: { borderType: "thin" },
      });

      // chess.js global from CDN
      const game = new Chess();

      function setOrientation() {
        board.setOrientation(myRole === "black" ? COLOR.black : COLOR.white);
      }

      function resetLocalGame() {
        game.reset();
        board.setPosition(game.fen());
        requestEval(game.fen());
      }

      function canMoveNow() {
        const turn = game.turn(); // "w"|"b"
        if (myRole === "white") return turn === "w";
        if (myRole === "black") return turn === "b";
        return false;
      }

      // ---------- Stockfish WASM (eval only) ----------
      // We run Stockfish in a Web Worker created from CDN script.
      // NO bestmove used, only "info score cp/mate".
      let sf = null;
      let evalJob = 0;

      function fmtEval(cp) {
        const v = cp / 100;
        const sign = v > 0 ? "+" : "";
        return sign + v.toFixed(1);
      }

      function setEvalBarFromCp(cp, opts = {}) {
        // opts:
        // - updateNumber: boolean (default true)
        // - label: string to force the number display (ex: "M3")
        const updateNumber = opts.updateNumber !== false;
        const label = typeof opts.label === "string" ? opts.label : null;

        // Normalize to +/- 600cp (6 pawns) for UI. Clamp hard.
        const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
        const c = clamp(cp, -600, 600);

        // White share in [0..100]
        const whitePct = 50 + c / 12; // 600cp -> +50 -> 100%
        const w = clamp(whitePct, 0, 100);
        const b = 100 - w;

        evalWhiteFill.style.width = `${w}%`;
        evalBlackFill.style.width = `${b}%`;

        if (label) {
          evalNumEl.textContent = label;
        } else if (updateNumber) {
          evalNumEl.textContent = fmtEval(cp);
        }
      }

      function initStockfish() {
        // Stockfish worker script (cdn). This is the common browser bundle.
        // If this URL ever changes, we’ll swap it, but it’s a solid default.
        const url = "https://cdn.jsdelivr.net/npm/stockfish@16.0.0/src/stockfish.js";

        sf = new Worker(url);
        engineStatusEl.textContent = "engine: starting…";

        sf.onmessage = (e) => {
          const line = (e.data || "").toString();

          if (!engineReady && (line.includes("uciok") || line.includes("readyok"))) {
            // We'll set ready after we send isready (below)
          }

          // Parse eval lines: "info depth ... score cp 34"
          if (line.startsWith("info") && line.includes("score")) {
            // ignore if not latest job
            if (!currentEvalAccepting) return;

            const mCp = line.match(/score cp (-?\d+)/);
            const mMate = line.match(/score mate (-?\d+)/);

            if (mMate) {
              // Represent mate as a huge score for bar + show "M#"
              const mateN = parseInt(mMate[1], 10);
              const mateText = (mateN > 0 ? "+M" : "-M") + Math.abs(mateN);

              // push bar hard to the winning side + show mate text
              setEvalBarFromCp(mateN > 0 ? 600 : -600, { updateNumber: false, label: mateText });
              return;
            }

            if (mCp) {
              const cp = parseInt(mCp[1], 10);
              // Stockfish score is from side-to-move POV in many builds; we want White POV.
              // Convert to White POV using whose turn it is in our game state.
              // If it's Black to move, invert.
              const whitePov = game.turn() === "w" ? cp : -cp;
              setEvalBarFromCp(whitePov);
            }
          }

          // Useful for debugging
          if (line === "uciok") {
            sf.postMessage("isready");
          }
          if (line === "readyok") {
            engineReady = true;
            engineStatusEl.textContent = "engine: ready";
            // initial eval
            requestEval(game.fen());
          }
        };

        sf.onerror = (e) => {
          console.error("stockfish worker error", e);
          engineStatusEl.textContent = "engine: error";
          err("Stockfish failed to start (worker error).");
        };

        // init uci
        sf.postMessage("uci");
      }

      let currentEvalAccepting = false;

      function requestEval(fen) {
        if (!sf || !engineReady) return;

        // cancel prior "accepting" windows
        evalJob += 1;
        const jobId = evalJob;

        currentEvalAccepting = true;

        // Set a short timeout so stale eval lines don't keep updating forever
        setTimeout(() => {
          if (jobId === evalJob) currentEvalAccepting = false;
        }, 2500);

        sf.postMessage("stop");
        sf.postMessage("ucinewgame");
        sf.postMessage("position fen " + fen);
        // Depth tuned for responsiveness. You can raise to 14/16 later.
        sf.postMessage("go depth 12");
      }

      initStockfish();
      setEvalBarFromCp(0);

      // ---------- Socket ----------
      if (typeof io === "undefined") {
        err("Socket.IO client did not load. /socket.io/socket.io.js failed.");
        throw new Error("io is undefined");
      }

      const socket = io({
        transports: ["polling", "websocket"],
      });

      socket.on("connect", () => {
        sys("connected");
      });

      socket.on("disconnect", () => {
        warn("disconnected");
      });

      socket.on("connect_error", (e) => {
        console.error("connect_error", e);
        err("socket connect_error: " + (e?.message || e));
      });

      socket.on("status", (m) => sys(m?.msg || "status"));

      socket.on("queue:status", ({ state }) => {
        if (state === "searching") {
          clearSession();
          setMode("searching");
        } else {
          // staying idle outside a room
          if (!currentRoom) clearSession();
          setMode("idle");
        }
      });

      socket.on("match:found", ({ room, role }) => {
        // role is "w"|"b"
        currentRoom = room;
        myRole = role === "w" ? "white" : "black";
        setMode("matched");
        updateTopPills(2);
        setOrientation();
        resetLocalGame();
        const u = new URL(location.href);
        u.searchParams.set("room", currentRoom);
        history.replaceState({}, "", u);
        ok(`match found: ${room} (${myRole})`);
      });

      socket.on("room:created", ({ room }) => {
        currentRoom = room;
        myRole = "white";
        setMode("matched");
        updateTopPills(1);
        setOrientation();
        resetLocalGame();

        const u = new URL(location.href);
        u.searchParams.set("room", currentRoom);
        history.replaceState({}, "", u);

        ok(`room created: ${room}`);
      });

      socket.on("room:joined", ({ room, role, players }) => {
        currentRoom = room;
        myRole = role === "w" ? "white" : "black";
        setMode("matched");
        updateTopPills(players ?? null);
        setOrientation();
        resetLocalGame();

        const u = new URL(location.href);
        u.searchParams.set("room", currentRoom);
        history.replaceState({}, "", u);

        ok(`joined room: ${room} (${myRole})`);
      });

      socket.on("room:update", ({ room, players }) => {
        if (!room || room !== currentRoom) return;
        if (typeof players === "number") playersEl.textContent = String(players);
      });

      socket.on("game:start", () => ok("game started"));

      socket.on("opponent:left", () => {
        warn("opponent left");
        // you stay in room but game is effectively over.
      });

      socket.on("move", ({ fen }) => {
        if (!fen) return;
        // Apply opponent move to local game
        game.load(fen);
        board.setPosition(game.fen());
        requestEval(game.fen());
      });

      socket.on("chat", (m) => {
        try {
          if (!m) return;
          if (m.kind === "sys") {
            addMsg("sys", m.at || "sys", m.text || "");
          } else if (m.kind === "user") {
            addMsg("user", `${m.at || ""} ${m.from || ""}`.trim(), m.text || "");
          } else {
            const who = m.from || "player";
            addMsg("chat", who, m.text || "");
          }
        } catch (e) {
          console.error("chat handler error", e);
        }
      });

      // ---------- Move input ----------
      board.enableMoveInput((event) => {
        if (!currentRoom) return false;
        if (!(myRole === "white" || myRole === "black")) return false;
        if (mode !== "matched") return false;

        if (event.type === INPUT_EVENT_TYPE.moveInputStarted) {
          return canMoveNow();
        }

        if (event.type === INPUT_EVENT_TYPE.validateMoveInput) {
          if (!canMoveNow()) {
            sys("not your turn");
            board.setPosition(game.fen());
            return false;
          }

          const from = event.squareFrom;
          const to = event.squareTo;

          const mv = game.move({ from, to, promotion: "q" });
          if (!mv) {
            sys("illegal move");
            board.setPosition(game.fen());
            return false;
          }

          board.setPosition(game.fen());
          requestEval(game.fen());

          socket.emit("move", {
            move: { from, to, promotion: "q" },
            fen: game.fen(),
            pgn: game.pgn(),
          });

          return true;
        }

        return true;
      });

      // ---------- Buttons ----------
      playOnlineBtn.onclick = () => {
        clearSession();
        sys("searching for opponent…");
        setMode("searching");
        socket.emit("queue:join");
      };

      cancelBtn.onclick = () => {
        socket.emit("queue:cancel");
        clearSession();
        setMode("idle");
      };

      createBtn.onclick = () => {
        setMode("idle");
        socket.emit("queue:cancel");
        sys("creating room…");
        socket.emit("room:create");
      };

      joinBtn.onclick = () => {
        const code = (joinInput.value || "").trim().toUpperCase();
        if (!code) return;
        setMode("idle");
        socket.emit("queue:cancel");
        sys(`joining ${code}…`);
        socket.emit("room:join", { room: code });
      };

      restartBtn.onclick = () => {
        resetLocalGame();
        sys("restarted (local)");
      };

      copyBtn.onclick = async () => {
        const u = new URL(location.href);
        if (currentRoom) u.searchParams.set("room", currentRoom);
        await navigator.clipboard.writeText(u.toString());
        ok("room link copied");
      };

      function sendChat() {
        const t = (chatInput.value || "").trim();
        if (!t) return;
        socket.emit("chat:send", { text: t });
        chatInput.value = "";
      }

      sendBtn.onclick = sendChat;
      chatInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") sendChat();
      });

      // auto-join from URL
      const roomParam = new URL(location.href).searchParams.get("room");
      if (roomParam) {
        const code = roomParam.trim().toUpperCase();
        sys(`joining ${code}…`);
        socket.emit("room:join", { room: code });
      }

      // initial UI
      setMode("idle");
      updateTopPills(0);
      sys("ready");
    </script>
  </body>
</html>

