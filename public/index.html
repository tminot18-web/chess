<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Live Eval Chess</title>

    <!-- ✅ Keep cm-chessboard CSS + assets on SAME VERSION as the JS import -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/cm-chessboard@8.7.8/assets/chessboard.css"
    />
    <link rel="icon" href="data:," />

    <style>
      :root {
        --bg: #0b0f14;
        --text: #dbe3ee;
        --muted: rgba(219, 227, 238, 0.7);
        --border: rgba(219, 227, 238, 0.12);
        --shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
        --radius: 16px;

        --gap: 14px;
        --pad: 14px;
        --rightW: 360px;

        /* chat height = half of right column */
        --chatFrac: 0.50;
      }

      * { box-sizing: border-box; }

      html, body {
        height: 100%;
        margin: 0;
        overflow: hidden; /* ✅ no page scroll */
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        background:
          radial-gradient(1200px 700px at 30% 10%, rgba(124, 92, 255, 0.15), transparent 60%),
          radial-gradient(800px 500px at 80% 30%, rgba(40, 209, 124, 0.12), transparent 60%),
          var(--bg);
        color: var(--text);
      }

      .wrap {
        height: 100vh;
        width: 100vw;
        padding: var(--pad);
        display: grid;
        grid-template-columns: 1fr var(--rightW);
        gap: var(--gap);
        min-height: 0;
      }

      .card {
        background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
        border: 1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        min-height: 0;
        overflow: hidden;
      }

      .header {
        padding: 14px 16px;
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
      }

      .title { font-size: 16px; font-weight: 800; letter-spacing: 0.3px; }

      .pillRow { display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end; }
      .pill {
        font-size: 12px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(255,255,255,0.03);
        color: var(--muted);
      }
      .pill strong { color: var(--text); }

      /* LEFT: board should dominate */
      .left {
        display: grid;
        grid-template-rows: auto 1fr;
        min-height: 0;
      }

      .boardStage {
        padding: 14px;
        display: grid;
        place-items: center;
        min-height: 0;
      }

      /* ✅ Make board the biggest thing on screen */
      #board {
        width: min(
          calc(100vw - var(--rightW) - (var(--pad) * 2) - var(--gap) - 28px),
          calc(100vh - (var(--pad) * 2) - 74px)
        );
        height: min(
          calc(100vw - var(--rightW) - (var(--pad) * 2) - var(--gap) - 28px),
          calc(100vh - (var(--pad) * 2) - 74px)
        );
        border-radius: 14px;
        overflow: hidden;
      }

      /* RIGHT: controls top-right; chat takes ~half */
      .right {
        display: grid;
        grid-template-rows: calc((1 - var(--chatFrac)) * 100%) calc(var(--chatFrac) * 100%);
        gap: var(--gap);
        min-height: 0;
      }

      .panelBody { padding: 12px 14px; }

      .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }

      button, input { font: inherit; }
      button {
        border: 1px solid var(--border);
        background: rgba(255,255,255,0.04);
        color: var(--text);
        padding: 10px 12px;
        border-radius: 12px;
        cursor: pointer;
      }
      button.primary {
        border-color: rgba(124,92,255,0.45);
        background: rgba(124,92,255,0.18);
      }
      button.danger {
        border-color: rgba(255,77,77,0.45);
        background: rgba(255,77,77,0.12);
      }
      button.neutral {
        border-color: rgba(219,227,238,0.18);
        background: rgba(255,255,255,0.03);
      }
      button:disabled { opacity: 0.45; cursor: not-allowed; }

      input[type="text"] {
        flex: 1;
        min-width: 160px;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(0,0,0,0.25);
        color: var(--text);
        outline: none;
      }

      .kv { display: grid; grid-template-columns: 1fr auto; gap: 10px; margin-top: 10px; }
      .kv .k { color: var(--muted); font-size: 12px; }
      .kv .v { font-weight: 800; font-size: 28px; }

      .modeLine { margin-top: 10px; font-size: 12px; color: var(--muted); }
      .modeLine strong { color: var(--text); }

      .evalBarWrap {
        margin-top: 10px;
        height: 14px;
        border-radius: 999px;
        background: rgba(255,255,255,0.06);
        border: 1px solid var(--border);
        position: relative;
        overflow: hidden;
      }
      .evalFill {
        position: absolute;
        inset: 0;
        width: 50%;
        background: linear-gradient(90deg, rgba(40,209,124,0.0), rgba(40,209,124,0.55));
      }
      .evalMarker {
        position: absolute;
        top: 0;
        bottom: 0;
        left: calc(50% - 1px);
        width: 2px;
        background: rgba(124,92,255,0.85);
      }

      .chatCard {
        display: grid;
        grid-template-rows: auto 1fr auto;
        min-height: 0;
      }

      .feed {
        min-height: 0;
        overflow: auto; /* ✅ internal scroll only */
        padding: 10px 12px;
        border-top: 1px solid var(--border);
      }

      .msg {
        margin: 0 0 10px 0;
        padding: 10px 10px;
        border: 1px solid rgba(219,227,238,0.12);
        background: rgba(0,0,0,0.18);
        border-radius: 12px;
      }
      .msg .meta {
        display: flex;
        gap: 8px;
        margin-bottom: 6px;
        color: rgba(219,227,238,0.75);
        font-size: 11px;
      }
      .tag {
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid rgba(219,227,238,0.15);
        background: rgba(255,255,255,0.03);
      }
      .tag.sys { border-color: rgba(124,92,255,0.25); }
      .tag.user { border-color: rgba(40,209,124,0.25); }
      .tag.err { border-color: rgba(255,77,77,0.35); }
      .msg .text { white-space: pre-wrap; font-size: 13px; line-height: 1.35; }

      .chatRow { display: flex; gap: 8px; padding: 12px 12px 14px 12px; }

      @media (max-width: 1050px) {
        :root { --rightW: 100%; }
        .wrap {
          grid-template-columns: 1fr;
          grid-template-rows: 60vh 40vh;
        }
        #board {
          width: min(calc(100vw - (var(--pad) * 2) - 28px), calc(60vh - 70px));
          height: min(calc(100vw - (var(--pad) * 2) - 28px), calc(60vh - 70px));
        }
      }
    </style>

    <script src="/socket.io/socket.io.js"></script>

    <!-- ✅ Use the UMD that defines window.Chess -->
    <script src="https://cdn.jsdelivr.net/npm/chess.js@0.10.3/chess.min.js"></script>
  </head>

  <body>
    <div class="wrap">
      <div class="card left">
        <div class="header">
          <div>
            <div class="title">Live Eval Chess</div>
            <div style="font-size:12px;color:var(--muted)">Online rooms + local Stockfish eval (browser)</div>
          </div>
          <div class="pillRow">
            <div class="pill">mode: <strong id="modeText">idle</strong></div>
            <div class="pill">room: <strong id="roomPill">—</strong></div>
            <div class="pill">players: <strong id="playersPill">0</strong></div>
            <div class="pill">role: <strong id="rolePill">—</strong></div>
          </div>
        </div>

        <div class="boardStage">
          <div id="board"></div>
        </div>
      </div>

      <div class="right">
        <div class="card">
          <div class="header">
            <div class="title">Controls</div>
            <div class="pillRow">
              <div class="pill">engine: <strong id="engineStatus">starting…</strong></div>
            </div>
          </div>

          <div class="panelBody">
            <div class="row">
              <button id="playOnlineBtn" class="primary">Play Online</button>
              <button id="cancelBtn" class="danger" disabled>Cancel</button>

              <!-- ✅ replace Restart with Draw + Resign -->
              <button id="drawBtn" class="neutral" disabled>Draw</button>
              <button id="resignBtn" class="danger" disabled>Resign</button>

              <button id="copyBtn" disabled>Copy Link</button>
            </div>

            <div class="kv">
              <div class="k">Eval</div>
              <div class="v" id="evalNum">+0.0</div>
            </div>

            <div class="evalBarWrap" aria-hidden="true">
              <div class="evalFill" id="evalFill"></div>
              <div class="evalMarker"></div>
            </div>

            <div class="modeLine">
              You can only move when it’s your turn.
            </div>

            <hr style="border:none;border-top:1px solid var(--border);margin:14px 0" />

            <div class="row" style="margin-bottom: 8px">
              <button id="createBtn">Create Room</button>
              <input id="joinInput" type="text" placeholder="ROOM CODE" />
              <button id="joinBtn">Join</button>
            </div>

            <div style="color: var(--muted); font-size: 12px">
              Matchmaking waits for 2 players. Friend rooms use ?room=CODE.
            </div>
          </div>
        </div>

        <div class="card chatCard">
          <div class="header">
            <div class="title">Room Feed</div>
            <div class="pillRow"><div class="pill">log</div></div>
          </div>

          <div id="feed" class="feed"></div>

          <div class="chatRow">
            <input id="chatInput" type="text" placeholder="message…" />
            <button id="sendBtn">Send</button>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import { COLOR, Chessboard, FEN, INPUT_EVENT_TYPE } from "https://unpkg.com/cm-chessboard@8.7.8/src/Chessboard.js";

      // ---------- DOM ----------
      const feedEl = document.getElementById("feed");
      const roomEl = document.getElementById("roomPill");
      const roleEl = document.getElementById("rolePill");
      const playersEl = document.getElementById("playersPill");
      const modeTextEl = document.getElementById("modeText");

      const evalNumEl = document.getElementById("evalNum");
      const evalFillEl = document.getElementById("evalFill");
      const engineStatusEl = document.getElementById("engineStatus");

      const playOnlineBtn = document.getElementById("playOnlineBtn");
      const cancelBtn = document.getElementById("cancelBtn");
      const copyBtn = document.getElementById("copyBtn");

      const drawBtn = document.getElementById("drawBtn");
      const resignBtn = document.getElementById("resignBtn");

      const createBtn = document.getElementById("createBtn");
      const joinBtn = document.getElementById("joinBtn");
      const joinInput = document.getElementById("joinInput");

      const chatInput = document.getElementById("chatInput");
      const sendBtn = document.getElementById("sendBtn");

      // ---------- Feed helpers ----------
      function addMsg(kind, from, text) {
        const d = document.createElement("div");
        d.className = "msg";
        const meta = document.createElement("div");
        meta.className = "meta";
        const tag = document.createElement("span");
        tag.className = "tag " + (kind === "sys" ? "sys" : kind === "err" ? "err" : "user");
        tag.textContent = kind;
        const who = document.createElement("span");
        who.textContent = from;
        meta.appendChild(tag);
        meta.appendChild(who);

        const body = document.createElement("div");
        body.className = "text";
        body.textContent = text;

        d.appendChild(meta);
        d.appendChild(body);
        feedEl.appendChild(d);
        feedEl.scrollTop = feedEl.scrollHeight;
      }
      const ts = () => new Date().toTimeString().slice(0, 8);
      const sys = (t) => addMsg("sys", ts(), t);
      const err = (t) => addMsg("err", "error", t);

      window.addEventListener("error", (e) => err(e?.message || String(e)));
      window.addEventListener("unhandledrejection", (e) =>
        err("unhandledrejection: " + (e?.reason?.message || String(e.reason)))
      );

      sys("booted");

      // ---------- State ----------
      let currentRoom = null;
      let myRole = null; // "white" | "black"
      let mode = "idle"; // idle | searching | matched
      let moveNumber = 0;
      let gameOver = false;

      // draw offer tracking
      let outgoingDrawPending = false;

      function setMode(next) {
        mode = next;
        modeTextEl.textContent = mode;

        const searching = mode === "searching";
        const matched = mode === "matched";

        playOnlineBtn.disabled = searching;
        cancelBtn.disabled = !searching;

        // enable/disable draw+resign only when in a matched game and not over
        drawBtn.disabled = !(matched && !gameOver);
        resignBtn.disabled = !(matched && !gameOver);

        copyBtn.disabled = !currentRoom;
      }

      function updateTopPills(players = null) {
        roomEl.textContent = currentRoom || "—";
        roleEl.textContent = myRole || "—";
        if (players !== null) playersEl.textContent = String(players);
        copyBtn.disabled = !currentRoom;
      }

      function clearSession() {
        currentRoom = null;
        myRole = null;
        gameOver = false;
        outgoingDrawPending = false;

        const u = new URL(location.href);
        u.searchParams.delete("room");
        history.replaceState({}, "", u);

        updateTopPills(0);
        setMode("idle");
      }

      function endGameLocal(reason) {
        if (gameOver) return;
        gameOver = true;
        sys(reason);
        setMode(mode); // refresh button states
      }

      // ---------- Board ----------
      const boardEl = document.getElementById("board");

      const board = new Chessboard(boardEl, {
        assetsUrl: "https://unpkg.com/cm-chessboard@8.7.8/assets/",
        position: FEN.start,
        orientation: COLOR.white,
        style: { borderType: "thin" },
      });
      board.setPosition(FEN.start);

      const game = new window.Chess();

      function setOrientation() {
        board.setOrientation(myRole === "black" ? COLOR.black : COLOR.white);
      }

      function shouldShowEval() {
        return game.history().length > 0;
      }

      // ---------- Eval UI ----------
      function fmtEval(cp) {
        const v = cp / 100;
        const sign = v > 0 ? "+" : "";
        return sign + v.toFixed(1);
      }

      function setEvalFromCp(cp, label = null) {
        evalNumEl.textContent = label ? label : fmtEval(cp);

        const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
        const c = clamp(cp, -600, 600);
        const pct = clamp(50 + c / 12, 0, 100);
        evalFillEl.style.width = pct + "%";
      }
      setEvalFromCp(0);

      function resetLocalGame() {
        game.reset();
        moveNumber = 0;
        gameOver = false;
        outgoingDrawPending = false;
        board.setPosition(game.fen());
        setEvalFromCp(0);
        requestEval(game.fen());
        setMode(mode);
      }

      function canMoveNow() {
        if (gameOver) return false;
        const turn = game.turn();
        if (myRole === "white") return turn === "w";
        if (myRole === "black") return turn === "b";
        return false;
      }

      // ---------- Stockfish worker ----------
      let sf = null;
      let engineReady = false;
      let evalJob = 0;
      let accepting = false;

      function initStockfish() {
        engineStatusEl.textContent = "starting…";
        try {
          sf = new Worker("/engine/stockfish-uci.js");
        } catch (e) {
          engineStatusEl.textContent = "error";
          err("Stockfish worker failed to construct: " + (e?.message || e));
          return;
        }

        sf.onmessage = (e) => {
          const line = (e.data || "").toString();
          if (!line) return;

          if (line === "uciok") sf.postMessage("isready");
          if (line === "readyok") {
            engineReady = true;
            engineStatusEl.textContent = "ready";
            sys("engine ready");
            requestEval(game.fen());
            return;
          }

          if (!accepting) return;
          if (!line.startsWith("info") || !line.includes("score")) return;
          if (!shouldShowEval()) return;

          const mMate = line.match(/score mate (-?\d+)/);
          if (mMate) {
            const mateN = parseInt(mMate[1], 10);
            const mateText = (mateN > 0 ? "+M" : "-M") + Math.abs(mateN);
            setEvalFromCp(mateN > 0 ? 600 : -600, mateText);
            return;
          }

          const mCp = line.match(/score cp (-?\d+)/);
          if (mCp) {
            const cp = parseInt(mCp[1], 10);
            const whitePov = game.turn() === "w" ? cp : -cp;
            setEvalFromCp(whitePov);
          }
        };

        sf.onerror = (e) => {
          engineStatusEl.textContent = "error";
          err("Stockfish worker error (see console).");
          console.error("stockfish worker error", e);
        };

        sf.postMessage("uci");
      }

      function requestEval(fen) {
        if (!sf || !engineReady) return;

        evalJob += 1;
        const jobId = evalJob;
        accepting = true;
        setTimeout(() => {
          if (jobId === evalJob) accepting = false;
        }, 2500);

        sf.postMessage("stop");
        sf.postMessage("ucinewgame");
        sf.postMessage("position fen " + fen);
        sf.postMessage("go depth 12");
      }

      initStockfish();

      // ---------- Socket ----------
      const socket = io({ transports: ["polling", "websocket"] });

      socket.on("connect", () => sys("socket connected"));
      socket.on("disconnect", () => sys("socket disconnected"));
      socket.on("connect_error", (e) => {
        err("socket connect_error: " + (e?.message || e));
        console.error("connect_error", e);
      });

      socket.on("queue:status", ({ state }) => {
        if (state === "searching") {
          clearSession();
          setMode("searching");
          sys("searching…");
        } else {
          setMode("idle");
          sys("idle");
        }
      });

      socket.on("match:found", ({ room, role }) => {
        currentRoom = room;
        myRole = role === "w" ? "white" : "black";
        gameOver = false;
        outgoingDrawPending = false;

        setMode("matched");
        updateTopPills(2);
        setOrientation();
        resetLocalGame();
        socket.emit("state:request", { room: currentRoom });

        const u = new URL(location.href);
        u.searchParams.set("room", currentRoom);
        history.replaceState({}, "", u);

        sys(`match found: ${room} (${myRole})`);
      });

      socket.on("room:created", ({ room }) => {
        currentRoom = room;
        myRole = "white";
        gameOver = false;
        outgoingDrawPending = false;

        setMode("matched");
        updateTopPills(1);
        setOrientation();
        resetLocalGame();
        socket.emit("state:request", { room: currentRoom });

        const u = new URL(location.href);
        u.searchParams.set("room", currentRoom);
        history.replaceState({}, "", u);

        sys(`room created: ${room}`);
      });

      socket.on("room:joined", ({ room, role, players }) => {
        currentRoom = room;
        myRole = role === "w" ? "white" : "black";
        gameOver = false;
        outgoingDrawPending = false;

        setMode("matched");
        updateTopPills(players ?? null);
        setOrientation();
        resetLocalGame();
        socket.emit("state:request", { room: currentRoom });

        const u = new URL(location.href);
        u.searchParams.set("room", currentRoom);
        history.replaceState({}, "", u);

        sys(`joined: ${room} (${myRole})`);
      });

      socket.on("room:update", ({ room, players }) => {
        if (room === currentRoom) updateTopPills(players);
      });

      socket.on("room:error", ({ error }) => sys("room error: " + error));
      socket.on("opponent:left", () => {
        sys("opponent left");
      });

      socket.on("state:sync", (s) => {
        try {
          if (!s || !s.fen) return;
          game.load(s.fen);
          board.setPosition(game.fen());
          moveNumber = typeof s.moveNumber === "number" ? s.moveNumber : 0;
          requestEval(game.fen());
          if (typeof s.players === "object") {
            const players = (s.players.w ? 1 : 0) + (s.players.b ? 1 : 0);
            updateTopPills(players);
          }
        } catch (e) {
          console.error("state:sync error", e);
        }
      });

      socket.on("move:accepted", ({ fen, moveNumber: mn }) => {
        if (!fen) return;
        game.load(fen);
        board.setPosition(game.fen());
        if (typeof mn === "number") moveNumber = mn;
        requestEval(game.fen());
      });

      socket.on("move:rejected", (p) => {
        try {
          if (p && p.fen) {
            game.load(p.fen);
            board.setPosition(game.fen());
            moveNumber = typeof p.moveNumber === "number" ? p.moveNumber : moveNumber;
            requestEval(game.fen());
          }
          if (p && p.reason) sys("move rejected: " + p.reason);
        } catch (e) {
          console.error("move:rejected error", e);
        }
      });

      socket.on("chat", (m) => {
        try {
          if (!m) return;
          if (m.kind === "sys") addMsg("sys", m.at || "sys", m.text || "");
          else if (m.kind === "user") addMsg("user", `${m.at || ""} ${m.from || ""}`.trim(), m.text || "");
          else addMsg("sys", "chat", m.text || "");
        } catch (e) {
          console.error("chat handler error", e);
        }
      });

      // -----------------------------
      // ✅ Draw + Resign protocol (client side)
      // -----------------------------

      // Incoming draw offer from opponent
      socket.on("draw:offer", (payload = {}) => {
        if (!currentRoom) return;
        if (payload.room && payload.room !== currentRoom) return;
        if (gameOver) return;

        sys("draw offer received");

        // Simple UX: confirm dialog. Replace with custom modal later.
        const accept = window.confirm("Opponent offered a draw. Accept?");
        socket.emit("draw:response", { room: currentRoom, accept });

        if (accept) {
          endGameLocal("draw agreed");
        } else {
          sys("draw declined");
        }
      });

      // Response to our draw offer (if server forwards it)
      socket.on("draw:response", (payload = {}) => {
        if (!currentRoom) return;
        if (payload.room && payload.room !== currentRoom) return;

        const accept = !!payload.accept;
        outgoingDrawPending = false;
        drawBtn.disabled = !(mode === "matched" && !gameOver);

        if (accept) {
          endGameLocal("draw agreed");
        } else {
          sys("draw declined");
        }
      });

      // If server chooses to broadcast a final draw event instead
      socket.on("draw:accepted", (payload = {}) => {
        if (!currentRoom) return;
        if (payload.room && payload.room !== currentRoom) return;
        outgoingDrawPending = false;
        endGameLocal("draw agreed");
      });

      socket.on("draw:declined", (payload = {}) => {
        if (!currentRoom) return;
        if (payload.room && payload.room !== currentRoom) return;
        outgoingDrawPending = false;
        sys("draw declined");
        drawBtn.disabled = !(mode === "matched" && !gameOver);
      });

      // If server broadcasts resign info
      socket.on("game:resigned", (payload = {}) => {
        if (!currentRoom) return;
        if (payload.room && payload.room !== currentRoom) return;

        // payload.by could be "white"/"black" or socket id
        const by = payload.by ? String(payload.by) : "a player";
        endGameLocal(`${by} resigned`);
      });

      socket.on("game:ended", (payload = {}) => {
        if (!currentRoom) return;
        if (payload.room && payload.room !== currentRoom) return;
        const reason = payload.reason ? String(payload.reason) : "game ended";
        endGameLocal(reason);
      });

      // Move input
      board.enableMoveInput((event) => {
        if (!currentRoom) return false;
        if (mode !== "matched") return false;
        if (!(myRole === "white" || myRole === "black")) return false;
        if (gameOver) return false;

        if (event.type === INPUT_EVENT_TYPE.moveInputStarted) return canMoveNow();

        if (event.type === INPUT_EVENT_TYPE.validateMoveInput) {
          if (!canMoveNow()) {
            sys("not your turn");
            board.setPosition(game.fen());
            return false;
          }

          const from = event.squareFrom;
          const to = event.squareTo;

          const mv = game.move({ from, to, promotion: "q" });
          if (!mv) {
            sys("illegal move");
            board.setPosition(game.fen());
            return false;
          }

          board.setPosition(game.fen());
          requestEval(game.fen());

          socket.emit("move:submit", {
            room: currentRoom,
            move: { from, to, promotion: "q" },
            clientMoveNumber: moveNumber,
          });

          return true;
        }

        return true;
      });

      // Controls
      playOnlineBtn.onclick = () => {
        sys("Play Online");
        clearSession();
        setMode("searching");
        socket.emit("queue:join");
      };

      cancelBtn.onclick = () => {
        sys("Cancel");
        socket.emit("queue:cancel");
        clearSession();
        setMode("idle");
      };

      createBtn.onclick = () => {
        sys("Create Room");
        socket.emit("queue:cancel");
        socket.emit("room:create");
      };

      joinBtn.onclick = () => {
        const code = (joinInput.value || "").trim().toUpperCase();
        if (!code) return;
        sys("Join: " + code);
        socket.emit("queue:cancel");
        socket.emit("room:join", { room: code });
      };

      copyBtn.onclick = async () => {
        const u = new URL(location.href);
        if (currentRoom) u.searchParams.set("room", currentRoom);
        history.replaceState({}, "", u);
        await navigator.clipboard.writeText(u.toString());
        sys("room link copied");
      };

      // ✅ Draw button: offer draw
      drawBtn.onclick = () => {
        if (!currentRoom || mode !== "matched" || gameOver) return;
        if (outgoingDrawPending) return;

        outgoingDrawPending = true;
        drawBtn.disabled = true;
        sys("draw offer sent");
        socket.emit("draw:offer", { room: currentRoom });
      };

      // ✅ Resign button: resign immediately
      resignBtn.onclick = () => {
        if (!currentRoom || mode !== "matched" || gameOver) return;

        const ok = window.confirm("Resign this game?");
        if (!ok) return;

        socket.emit("game:resign", { room: currentRoom });
        endGameLocal("you resigned");
      };

      function sendChat() {
        const t = (chatInput.value || "").trim();
        if (!t) return;
        socket.emit("chat:send", { text: t });
        chatInput.value = "";
      }
      sendBtn.onclick = sendChat;
      chatInput.addEventListener("keydown", (e) => { if (e.key === "Enter") sendChat(); });

      // auto-join
      const roomParam = new URL(location.href).searchParams.get("room");
      if (roomParam) {
        const code = roomParam.trim().toUpperCase();
        sys("auto-join: " + code);
        socket.emit("room:join", { room: code });
      }

      // init
      setMode("idle");
      updateTopPills(0);
      resetLocalGame();
      sys("ready");
    </script>
  </body>
</html>

