<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Live Eval Chess — Online</title>

    <!-- cm-chessboard -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/cm-chessboard@3.15.5/styles/cm-chessboard.css"
    />

    <style>
      :root {
        --bg: #0b0f17;
        --panel: #101827;
        --panel2: #0e1625;
        --text: #e7eefc;
        --muted: #a7b4cf;
        --accent: #7dd3fc;
        --line: rgba(255, 255, 255, 0.08);
        --good: #22c55e;
        --bad: #ef4444;
      }

      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        background: radial-gradient(800px 400px at 20% 0%, rgba(125, 211, 252, 0.13), transparent 60%),
                    radial-gradient(600px 300px at 80% 10%, rgba(34, 197, 94, 0.10), transparent 60%),
                    var(--bg);
        color: var(--text);
      }

      .wrap {
        max-width: 1100px;
        margin: 0 auto;
        padding: 18px;
        display: grid;
        grid-template-columns: 520px 1fr;
        gap: 14px;
      }

      .card {
        background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
        border: 1px solid var(--line);
        border-radius: 14px;
        padding: 12px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      }

      .topbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        margin-bottom: 10px;
      }

      .brand {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .brand h1 {
        font-size: 16px;
        margin: 0;
        letter-spacing: 0.2px;
      }
      .brand span {
        font-size: 12px;
        color: var(--muted);
      }

      .pills { display: flex; gap: 6px; align-items: center; }
      .pill {
        border: 1px solid var(--line);
        padding: 5px 8px;
        border-radius: 999px;
        font-size: 12px;
        color: var(--muted);
        background: rgba(0,0,0,0.12);
      }

      .grid2 {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }

      #board { width: 496px; height: 496px; margin: 0 auto; }

      .controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }

      .controls .block {
        background: rgba(0,0,0,0.14);
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 10px;
      }

      button, input {
        font: inherit;
      }
      button {
        cursor: pointer;
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px 10px;
        color: var(--text);
        background: rgba(0,0,0,0.15);
        transition: transform .05s ease, background .2s ease;
      }
      button:hover { background: rgba(125,211,252,0.10); }
      button:active { transform: translateY(1px); }
      button.primary { border-color: rgba(125,211,252,0.4); }
      button.danger { border-color: rgba(239,68,68,0.4); }
      input {
        width: 100%;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: rgba(0,0,0,0.15);
        color: var(--text);
      }

      .row { display: flex; gap: 8px; }
      .row > * { flex: 1; }

      .sectionTitle {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 8px;
        letter-spacing: 0.3px;
        text-transform: uppercase;
      }

      .evalWrap {
        display: grid;
        grid-template-columns: 22px 1fr;
        gap: 10px;
        align-items: center;
      }

      .evalBar {
        width: 22px;
        height: 240px;
        border-radius: 999px;
        border: 1px solid var(--line);
        overflow: hidden;
        background: rgba(0,0,0,0.25);
        position: relative;
      }
      .evalFill {
        position: absolute;
        bottom: 0;
        width: 100%;
        height: 50%;
        background: linear-gradient(180deg, rgba(34,197,94,0.9), rgba(34,197,94,0.55));
      }

      .evalText {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .evalText .big {
        font-size: 28px;
        letter-spacing: 0.2px;
      }
      .evalText .sub {
        font-size: 12px;
        color: var(--muted);
        line-height: 1.4;
      }

      .chat {
        display: grid;
        grid-template-rows: auto 1fr auto;
        height: 100%;
        min-height: 620px;
      }

      .chatLog {
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 10px;
        background: rgba(0,0,0,0.14);
        overflow: auto;
        max-height: 530px;
      }

      .msg {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 8px;
        padding: 6px 0;
        border-bottom: 1px dashed rgba(255,255,255,0.06);
      }
      .msg:last-child { border-bottom: none; }
      .tag {
        font-size: 11px;
        padding: 2px 6px;
        border: 1px solid var(--line);
        border-radius: 999px;
        color: var(--muted);
        height: fit-content;
      }
      .msg .text {
        font-size: 13px;
        color: var(--text);
        line-height: 1.35;
        word-break: break-word;
      }
      .tag.sys { border-color: rgba(125,211,252,0.35); color: rgba(125,211,252,0.95); }
      .tag.user { border-color: rgba(255,255,255,0.12); color: var(--text); }

      .chatSend {
        margin-top: 10px;
        display: flex;
        gap: 8px;
      }
      .chatSend input { flex: 1; }
      .chatSend button { width: 120px; }

      .muted { color: var(--muted); font-size: 12px; }

      @media (max-width: 1020px) {
        .wrap { grid-template-columns: 1fr; }
        #board { width: min(496px, 92vw); height: min(496px, 92vw); }
        .chat { min-height: 520px; }
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <div class="card">
        <div class="topbar">
          <div class="brand">
            <h1>Live Eval Chess</h1>
            <span class="muted">Online rooms + local Stockfish eval (browser)</span>
          </div>
          <div class="pills">
            <div class="pill" id="modePill">idle</div>
            <div class="pill" id="roomPill">room: —</div>
            <div class="pill" id="playersPill">players: 0</div>
          </div>
        </div>

        <div id="board"></div>

        <div class="grid2" style="margin-top: 12px;">
          <div class="controls">
            <div class="block">
              <div class="sectionTitle">Online</div>
              <div class="row" style="margin-bottom: 8px;">
                <button class="primary" id="playOnlineBtn">Play Online</button>
                <button class="danger" id="cancelBtn">Cancel</button>
              </div>
              <div class="row">
                <button id="createBtn">Create Room</button>
                <button id="copyBtn">Copy Link</button>
              </div>
              <div style="height: 10px;"></div>
              <div class="row">
                <input id="joinInput" placeholder="ROOM CODE (e.g. 8KJ3QZ)" />
                <button id="joinBtn">Join</button>
              </div>
              <div style="height: 10px;"></div>
              <button id="restartBtn">Restart (Local Only)</button>
            </div>

            <div class="block">
              <div class="sectionTitle">Evaluation</div>
              <div class="evalWrap">
                <div class="evalBar" title="Engine eval (white good up, black good down)">
                  <div class="evalFill" id="evalFill"></div>
                </div>
                <div class="evalText">
                  <div class="big" id="evalBig">0.0</div>
                  <div class="sub" id="evalSub">
                    Eval is local (your device). Depth 14. Starts neutral until a move is made.
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="chat card" style="padding: 12px;">
            <div class="sectionTitle">Room Feed</div>
            <div class="chatLog" id="chatLog"></div>
            <div class="chatSend">
              <input id="chatInput" placeholder="Type a message…" />
              <button id="sendBtn">Send</button>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="sectionTitle">How it works</div>
        <div class="muted" style="line-height: 1.55;">
          <div>• Click <b>Play Online</b> to enter matchmaking (random opponent).</div>
          <div>• Or <b>Create Room</b> and share the link/code.</div>
          <div>• Engine runs in your browser (WASM Stockfish), so eval speed depends on your device.</div>
          <div>• Server is now authoritative for game state and supports resync after refresh/disconnect.</div>
        </div>
      </div>
    </div>

    <!-- deps -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chess.js@0.13.4/chess.min.js"></script>
    <script src="https://unpkg.com/cm-chessboard@3.15.5/cm-chessboard.js"></script>

    <script>
      const { Chess } = window;
      const { Chessboard, INPUT_EVENT_TYPE } = window;

      // ---------- DOM ----------
      const modePill = document.getElementById("modePill");
      const roomPill = document.getElementById("roomPill");
      const playersPill = document.getElementById("playersPill");

      const playOnlineBtn = document.getElementById("playOnlineBtn");
      const cancelBtn = document.getElementById("cancelBtn");
      const createBtn = document.getElementById("createBtn");
      const joinBtn = document.getElementById("joinBtn");
      const joinInput = document.getElementById("joinInput");
      const restartBtn = document.getElementById("restartBtn");
      const copyBtn = document.getElementById("copyBtn");

      const evalFill = document.getElementById("evalFill");
      const evalBig = document.getElementById("evalBig");
      const evalSub = document.getElementById("evalSub");

      const chatLog = document.getElementById("chatLog");
      const chatInput = document.getElementById("chatInput");
      const sendBtn = document.getElementById("sendBtn");

      // ---------- State ----------
      let currentRoom = null;
      let myRole = null; // "white" | "black"
      let mode = "idle"; // idle | searching | matched
      let moveNumber = 0;

      function setMode(m) {
        mode = m;
        modePill.textContent = m;
      }

      function updateTopPills(players) {
        roomPill.textContent = `room: ${currentRoom || "—"}`;
        playersPill.textContent = `players: ${players ?? 0}`;
      }

      function clearSession() {
        currentRoom = null;
        myRole = null;
        const u = new URL(location.href);
        u.searchParams.delete("room");
        history.replaceState({}, "", u);
        updateTopPills(0);
      }

      function addMsg(kind, tag, text) {
        const row = document.createElement("div");
        row.className = "msg";

        const t = document.createElement("div");
        t.className = `tag ${kind}`;
        t.textContent = tag;

        const b = document.createElement("div");
        b.className = "text";
        b.textContent = text;

        row.appendChild(t);
        row.appendChild(b);
        chatLog.appendChild(row);
        chatLog.scrollTop = chatLog.scrollHeight;
      }

      function sys(text) {
        addMsg("sys", "sys", text);
      }

      // ---------- Chess + Board ----------
      const game = new Chess();

      const board = new Chessboard(document.getElementById("board"), {
        position: game.fen(),
        style: {
          cssClass: "default",
          showCoordinates: true,
        },
        responsive: true,
      });

      function setOrientation() {
        if (myRole === "black") board.setOrientation("black");
        else board.setOrientation("white");
      }

      function resetLocalGame() {
        game.reset();
        moveNumber = 0;
        board.setPosition(game.fen());
        setEvalBarFromCp(0);          // ✅ start at 0.0
        requestEval(game.fen());      // still warms engine, but UI stays 0 until first move
      }

      function canMoveNow() {
        const turn = game.turn(); // "w" | "b"
        if (myRole === "white") return turn === "w";
        if (myRole === "black") return turn === "b";
        return false;
      }

      // ---------- Stockfish (browser worker) ----------
      let sf = null;
      let sfReady = false;
      let pendingEvalFen = null;
      let lastCp = 0;

      function ensureStockfish() {
        if (sf) return;
        sf = new Worker("/engine/stockfish-uci.js");
        sf.onmessage = (e) => {
          const line = (e.data || "").toString();
          if (!line) return;

          if (line === "uciok") {
            sfReady = true;
            return;
          }

          // parse evals
          // example: "info depth 14 ... score cp 23 ..."
          if (line.includes("score cp")) {
            const m = line.match(/score cp (-?\d+)/);
            if (m) {
              const cp = parseInt(m[1], 10);
              lastCp = cp;
              setEvalFromEngine(cp);
            }
          }

          // mate handling (optional)
          if (line.includes("score mate")) {
            const m = line.match(/score mate (-?\d+)/);
            if (m) {
              const mate = parseInt(m[1], 10);
              const cp = mate > 0 ? 10000 : -10000;
              lastCp = cp;
              setEvalFromEngine(cp, mate);
            }
          }
        };

        sf.postMessage("uci");
        sf.postMessage("setoption name Threads value 2");
        sf.postMessage("setoption name Hash value 64");
        sf.postMessage("isready");
      }

      function requestEval(fen) {
        ensureStockfish();
        pendingEvalFen = fen;
        if (!sfReady) return;

        sf.postMessage("ucinewgame");
        sf.postMessage("position fen " + fen);
        sf.postMessage("go depth 14");
      }

      function setEvalFromEngine(cp, mate = null) {
        // Convert to "white POV" and keep consistent direction.
        // chess.js returns side to move, but eval is from side-to-move in many engines.
        // We'll approximate to white POV by flipping when black to move.
        let whiteCp = cp;
        const turn = game.turn();
        if (turn === "b") whiteCp = -cp;

        if (mate !== null) {
          evalBig.textContent = mate > 0 ? `M${mate}` : `M${Math.abs(mate)}`;
          evalSub.textContent = "Mate sequence detected";
          setEvalBarFromCp(whiteCp);
          return;
        }

        const val = (whiteCp / 100).toFixed(1);
        evalBig.textContent = val;
        evalSub.textContent = "cp (centipawns) — white good up, black good down";
        setEvalBarFromCp(whiteCp);
      }

      function setEvalBarFromCp(whiteCp) {
        // map cp to 0..100% with a soft clamp
        const clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x));
        const normalized = clamp(whiteCp, -800, 800); // -8 to +8 range
        const pct = ((normalized + 800) / 1600) * 100; // 0..100
        evalFill.style.height = pct + "%";
      }

      // ---------- Socket ----------
      const socket = io();

      socket.on("connect", () => {
        sys("socket connected");
      });

      socket.on("queue:status", ({ state }) => {
        if (state === "searching") {
          clearSession();
          setMode("searching");
          sys("searching…");
        } else {
          setMode("idle");
          sys("idle");
        }
      });

      socket.on("match:found", ({ room, role }) => {
        currentRoom = room;
        myRole = role === "w" ? "white" : "black";
        setMode("matched");
        updateTopPills(2);
        setOrientation();
        resetLocalGame();
        socket.emit("state:request", { room: currentRoom });
        const u = new URL(location.href);
        u.searchParams.set("room", currentRoom);
        history.replaceState({}, "", u);
        sys(`match found: ${room} (${myRole})`);
      });

      socket.on("room:created", ({ room }) => {
        currentRoom = room;
        myRole = "white";
        setMode("matched");
        updateTopPills(1);
        setOrientation();
        resetLocalGame();
        socket.emit("state:request", { room: currentRoom });
        const u = new URL(location.href);
        u.searchParams.set("room", currentRoom);
        history.replaceState({}, "", u);
        sys(`room created: ${room}`);
      });

      socket.on("room:joined", ({ room, role, players }) => {
        currentRoom = room;
        myRole = role === "w" ? "white" : "black";
        setMode("matched");
        updateTopPills(players ?? null);
        setOrientation();
        resetLocalGame();
        socket.emit("state:request", { room: currentRoom });
        const u = new URL(location.href);
        u.searchParams.set("room", currentRoom);
        history.replaceState({}, "", u);
        sys(`joined: ${room} (${myRole})`);
      });

      socket.on("room:update", ({ room, players }) => {
        if (room === currentRoom) updateTopPills(players);
      });

      socket.on("room:error", ({ error }) => {
        sys("room error: " + error);
      });

      socket.on("opponent:left", () => sys("opponent left"));

      socket.on("state:sync", (s) => {
        try {
          if (!s || !s.fen) return;
          game.load(s.fen);
          board.setPosition(game.fen());
          moveNumber = typeof s.moveNumber === "number" ? s.moveNumber : 0;
          requestEval(game.fen());
          if (typeof s.players === "object") {
            const players = (s.players.w ? 1 : 0) + (s.players.b ? 1 : 0);
            updateTopPills(players);
          }
        } catch (e) {
          console.error("state:sync handler error", e);
        }
      });

      socket.on("move:accepted", ({ fen, moveNumber: mn }) => {
        if (!fen) return;
        game.load(fen);
        board.setPosition(game.fen());
        if (typeof mn === "number") moveNumber = mn;
        requestEval(game.fen());
      });

      socket.on("move:rejected", (p) => {
        // snap back to server truth
        try {
          if (p && p.fen) {
            game.load(p.fen);
            board.setPosition(game.fen());
            moveNumber = typeof p.moveNumber === "number" ? p.moveNumber : moveNumber;
            requestEval(game.fen());
          }
          if (p && p.reason) sys("move rejected: " + p.reason);
        } catch (e) {
          console.error("move:rejected handler error", e);
        }
      });

      socket.on("chat", (m) => {
        try {
          if (!m) return;
          if (m.kind === "sys") addMsg("sys", m.at || "sys", m.text || "");
          else if (m.kind === "user") addMsg("user", `${m.at || ""} ${m.from || ""}`.trim(), m.text || "");
          else addMsg("sys", "chat", m.text || "");
        } catch (e) {
          console.error("chat handler error", e);
        }
      });

      // ---------- Move input ----------
      board.enableMoveInput((event) => {
        if (!currentRoom) return false;
        if (mode !== "matched") return false;
        if (!(myRole === "white" || myRole === "black")) return false;

        if (event.type === INPUT_EVENT_TYPE.moveInputStarted) {
          return canMoveNow();
        }

        if (event.type === INPUT_EVENT_TYPE.validateMoveInput) {
          if (!canMoveNow()) {
            sys("not your turn");
            board.setPosition(game.fen());
            return false;
          }

          const from = event.squareFrom;
          const to = event.squareTo;

          // optimistic local apply (keeps current feel)
          const mv = game.move({ from, to, promotion: "q" });
          if (!mv) {
            sys("illegal move");
            board.setPosition(game.fen());
            return false;
          }

          board.setPosition(game.fen());
          requestEval(game.fen());

          socket.emit("move:submit", {
            room: currentRoom,
            move: { from, to, promotion: "q" },
            clientMoveNumber: moveNumber,
          });

          return true;
        }

        return true;
      });

      // ---------- Buttons ----------
      playOnlineBtn.onclick = () => {
        sys("Play Online clicked");
        clearSession();
        setMode("searching");
        socket.emit("queue:join");
      };

      cancelBtn.onclick = () => {
        sys("Cancel clicked");
        socket.emit("queue:cancel");
        clearSession();
        setMode("idle");
      };

      createBtn.onclick = () => {
        sys("Create clicked");
        socket.emit("queue:cancel");
        socket.emit("room:create");
      };

      joinBtn.onclick = () => {
        const code = (joinInput.value || "").trim().toUpperCase();
        if (!code) return;
        sys("Join clicked: " + code);
        socket.emit("queue:cancel");
        socket.emit("room:join", { room: code });
      };

      restartBtn.onclick = () => {
        resetLocalGame();
        sys("restarted (local)");
      };

      copyBtn.onclick = async () => {
        const u = new URL(location.href);
        if (currentRoom) u.searchParams.set("room", currentRoom);
        history.replaceState({}, "", u);
        await navigator.clipboard.writeText(u.toString());
        sys("room link copied");
      };

      function sendChat() {
        const t = (chatInput.value || "").trim();
        if (!t) return;
        socket.emit("chat:send", { text: t });
        chatInput.value = "";
      }

      sendBtn.onclick = sendChat;
      chatInput.addEventListener("keydown", (e) => { if (e.key === "Enter") sendChat(); });

      // auto-join from URL
      const roomParam = new URL(location.href).searchParams.get("room");
      if (roomParam) {
        const code = roomParam.trim().toUpperCase();
        sys("auto-join: " + code);
        socket.emit("room:join", { room: code });
      }

      // init UI
      setMode("idle");
      updateTopPills(0);
      resetLocalGame();
      sys("ready");
    </script>
  </body>
</html>

